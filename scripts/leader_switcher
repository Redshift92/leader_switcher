#!/usr/bin/env python

import rospy
import rospkg
import os
import json
import sys
from PIL import Image
from time import sleep

# from leader_switcher import solver
import leader_switcher.solver as solver

from std_msgs.msg import String

map_file = 'map_' + sys.argv[1] + '.png'

rospy.init_node('leader_switcher', anonymous=True)
pub = rospy.Publisher('plan2rviz_notifier', String, queue_size=10)
map_path = os.path.join(rospkg.RosPack().get_path('leader_switcher'), 'maps', map_file)
map_i = Image.open(map_path)
rate = rospy.Rate(4)

black = (0,0,0)
red = (255,0,0)
green = (0,255,0)
blue = (0,0,255)
white = (255,255,255)


obstacles_edges = []
obstacles_corners = []
obstacles = []
start_positions = []
goal_positions = []
free_space = []
leaders = []

def coord_diff(c1, c2):
    return (c1[0]-c2[0], c1[1]-c2[1])

def sort_start_goal():
    global start_positions, goal_positions
    diff_pos = None
    diffs = set()
    ordered_sp_diff = []
    for sp in start_positions:
        diffs.add(coord_diff(start_positions[0], sp))
        ordered_sp_diff.append(coord_diff(start_positions[0], sp))
    for c_i, candidate in enumerate(goal_positions):
        diff_pos = []
        g_diffs = set()
        for gp_i, gp in enumerate(goal_positions):
            g_diffs.add(coord_diff(candidate, gp))
            diff_pos.append((coord_diff(candidate, gp), gp_i))
        if g_diffs == diffs:
            break
    sorted_gp = [None]*len(goal_positions)
    for d_p in diff_pos:
        sorted_gp[ordered_sp_diff.index(d_p[0])] = goal_positions[d_p[1]]
    goal_positions = sorted_gp


def is_edge(x,y):
    white_ng = 0
    for xx in [(-1,0),(1,0),(0,1),(0,-1)]:
        if map_i.getpixel((x+xx[0],y+xx[1]))[0:3] == white:
            white_ng += 1
    if white_ng > 1:
        return (True, True)
    elif white_ng == 1:
        return (True, False)
    return (False, False)

players = { 'obstacles': [], 'agents': [] }
for x in range(map_i.size[0]):
    for y in range(map_i.size[1]):
        pix = map_i.getpixel((x, map_i.size[1] - y - 1))[0:3]
        if pix == black:
            edge_corner = is_edge(x, map_i.size[1] - y - 1)
            if edge_corner[0]:
                obstacles.append((x,y))
                if edge_corner[1]:
                    players['obstacles'].append((x,y, {'rgb': [255,255,0]}))
                    obstacles_corners.append((x,y))
                else:
                    players['obstacles'].append((x,y))
                    obstacles_edges.append((x,y))
        elif pix == red or pix == green:
            start_positions.append((x,y))
            if pix == red:
                players['agents'].append((x,y))
            else:
                leaders.append(len(start_positions)-1)
                players['agents'].append((x,y, {'rgb': [0,255,0]}))
        elif pix == blue:
            players['agents'].append((x,y, {'rgb': [0,0,255]}))
            goal_positions.append((x,y))
        else:
            free_space.append((x,y))

sleep(1)
pub.publish(json.dumps(players))

sort_start_goal()

solver.init_graph(free_space, [obstacles_corners, obstacles_edges, obstacles, obstacles_corners + obstacles_edges],
                    start_positions, leaders, goal_positions, map_i.size)

edges = solver.get_graph_edges()
players['edges'] = [ [[],[]] ]
for edge in edges:
    players['edges'][0][0].append(edge[0][0])
    players['edges'][0][1].append(edge[0][1])
    players['edges'][0][0].append(edge[1][0])
    players['edges'][0][1].append(edge[1][1])
pub.publish(json.dumps(players))

solver_params = [ float(param) for param in sys.argv[2:5] ]
print(solver_params)

solver.run(*solver_params)
print('run done')
states = solver.get_states_sequence()
print('got states: ',len(states))

players = { 'agents': None }

while not rospy.is_shutdown() and len(states) != 0:
    new_state = states.pop()
    ldr = new_state[new_state[-1]]
    new_state[new_state[-1]]= (ldr[0], ldr[1], {'rgb': [0,0,255]})
    players['agents'] = new_state[0:-1]
    pub.publish(json.dumps(players))
    rate.sleep()
